// This file is auto-generated by @hey-api/openapi-ts

export type SessionDescription = {
    sdp?: string;
    type?: 'answer' | 'offer';
};

export type TrackObject = {
    /**
     * If you want to share a track, it should be local. If you want to play a track shared by a remote agent, it should be remote
     */
    location?: 'local' | 'remote';
    /**
     * mid associated to track's transceiver. It also can be prefixed with \# to reference an existing transceiver by its trackName
     */
    mid?: string;
    /**
     * Session ID of the track owner. It should be set for remote tracks only
     */
    sessionId?: string;
    /**
     * Given name for the track
     */
    trackName?: string;
    /**
     * Make the associated transceiver bidirectional. This option works only when the SFU generates the offer
     */
    bidirectionalMediaStream?: boolean;
    /**
     * Give a hint to the SFU about the transceiver kind. This is required when the SFU generates the offer
     */
    kind?: string;
    /**
     * Simulcast configuration for the track
     */
    simulcast?: {
        /**
         * Preferred RID for simulcast streams
         */
        preferredRid?: string;
        /**
         * Controls what happens if there is not enough network resources available to send the preferredRid. 'none' means keep sending even if not enough bandwidth, 'asciibetical' uses a-z order to determine priority where a is most desirable and z is least desirable.
         */
        priorityOrdering?: 'none' | 'asciibetical';
        /**
         * Controls what happens when the rid currently being used or preferredRid is no longer being sent by the publisher. 'none' means do nothing, 'asciibetical' uses the next available layer after sorting the layers a-z.
         */
        ridNotAvailable?: 'none' | 'asciibetical';
    };
};

export type CloseTrackObject = {
    /**
     * mid associated to the track's transceiver to close
     */
    mid?: string;
};

export type TracksRequest = {
    sessionDescription?: SessionDescription;
    tracks?: Array<TrackObject>;
    /**
     * Assign a random track name to any new track in the offered SDP
     */
    autoDiscover?: boolean;
};

export type TracksResponse = {
    errorCode?: string;
    errorDescription?: string;
    requiresImmediateRenegotiation?: boolean;
    sessionDescription?: SessionDescription;
    tracks?: Array<TrackObject & {
        errorCode?: string;
        errorDescription?: string;
    }>;
};

export type NewSessionRequest = {
    sessionDescription?: SessionDescription;
};

export type NewSessionResponse = {
    errorCode?: string;
    errorDescription?: string;
    sessionDescription?: {
        sdp?: string;
        type?: 'answer' | 'offer';
    };
    sessionId: string;
};

export type CloseTracksRequest = {
    sessionDescription?: SessionDescription;
    tracks?: Array<CloseTrackObject>;
    /**
     * True if you want to stop just the data flow for the tracks, no WebRTC renegotiation
     */
    force?: boolean;
};

export type CloseTracksResponse = {
    errorCode?: string;
    errorDescription?: string;
    sessionDescription?: SessionDescription;
    tracks?: Array<CloseTrackObject & {
        errorCode?: string;
        errorDescription?: string;
    }>;
    requiresImmediateRenegotiation?: boolean;
};

export type GetSessionStateResponse = {
    errorCode?: string;
    errorDescription?: string;
    tracks?: Array<TrackObject & {
        status?: 'active' | 'inactive' | 'waiting';
    }>;
};

export type RenegotiateRequest = {
    sessionDescription?: SessionDescription;
};

export type RenegotiateResponse = {
    errorCode?: string;
    errorDescription?: string;
    sessionDescription?: SessionDescription;
};

export type ChangeTracksRequest = {
    /**
     * Map of track IDs to track objects for changing tracks
     */
    tracks?: {
        [key: string]: TrackObject;
    };
    sessionDescription?: SessionDescription;
};

export type UpdateTracksRequest = {
    /**
     * Array of track objects for updating tracks
     */
    tracks?: Array<TrackObject>;
    sessionDescription?: SessionDescription;
};

export type UpdateTracksResponse = {
    errorCode?: string;
    errorDescription?: string;
    requiresImmediateRenegotiation?: boolean;
    /**
     * Array of track objects with results
     */
    tracks?: Array<TrackObject & {
        errorCode?: string;
        errorDescription?: string;
    }>;
};

export type PostAppsByAppIdSessionsNewData = {
    body?: never;
    path: {
        /**
         * WebRTC application ID
         */
        appId: string;
    };
    query?: {
        /**
         * Session is intended to connect to an ICE-lite peer like a third party SFU/server
         */
        thirdparty?: boolean;
        /**
         * Associate session to an user-provided correlation id
         */
        correlationId?: string;
    };
    url: '/apps/{appId}/sessions/new';
};

export type PostAppsByAppIdSessionsNewResponses = {
    /**
     * Created
     */
    201: NewSessionResponse & unknown;
};

export type PostAppsByAppIdSessionsNewResponse = PostAppsByAppIdSessionsNewResponses[keyof PostAppsByAppIdSessionsNewResponses];

export type PostAppsByAppIdSessionsBySessionIdTracksNewData = {
    body?: TracksRequest;
    path: {
        /**
         * WebRTC application ID
         */
        appId: string;
        /**
         * Current PeerConnection session ID
         */
        sessionId: string;
    };
    query?: never;
    url: '/apps/{appId}/sessions/{sessionId}/tracks/new';
};

export type PostAppsByAppIdSessionsBySessionIdTracksNewResponses = {
    /**
     * OK
     */
    200: TracksResponse;
};

export type PostAppsByAppIdSessionsBySessionIdTracksNewResponse = PostAppsByAppIdSessionsBySessionIdTracksNewResponses[keyof PostAppsByAppIdSessionsBySessionIdTracksNewResponses];

export type PutAppsByAppIdSessionsBySessionIdRenegotiateData = {
    body?: RenegotiateRequest;
    path: {
        /**
         * WebRTC application ID
         */
        appId: string;
        sessionId: string;
    };
    query?: never;
    url: '/apps/{appId}/sessions/{sessionId}/renegotiate';
};

export type PutAppsByAppIdSessionsBySessionIdRenegotiateResponses = {
    /**
     * OK
     */
    200: RenegotiateResponse;
};

export type PutAppsByAppIdSessionsBySessionIdRenegotiateResponse = PutAppsByAppIdSessionsBySessionIdRenegotiateResponses[keyof PutAppsByAppIdSessionsBySessionIdRenegotiateResponses];

export type PutAppsByAppIdSessionsBySessionIdTracksCloseData = {
    body?: CloseTracksRequest & unknown;
    path: {
        /**
         * WebRTC application ID
         */
        appId: string;
        sessionId: string;
    };
    query?: never;
    url: '/apps/{appId}/sessions/{sessionId}/tracks/close';
};

export type PutAppsByAppIdSessionsBySessionIdTracksCloseResponses = {
    /**
     * OK
     */
    200: CloseTracksResponse;
};

export type PutAppsByAppIdSessionsBySessionIdTracksCloseResponse = PutAppsByAppIdSessionsBySessionIdTracksCloseResponses[keyof PutAppsByAppIdSessionsBySessionIdTracksCloseResponses];

export type PutAppsByAppIdSessionsBySessionIdTracksUpdateData = {
    body?: UpdateTracksRequest;
    path: {
        /**
         * WebRTC application ID
         */
        appId: string;
        /**
         * Current PeerConnection session ID
         */
        sessionId: string;
    };
    query?: never;
    url: '/apps/{appId}/sessions/{sessionId}/tracks/update';
};

export type PutAppsByAppIdSessionsBySessionIdTracksUpdateResponses = {
    /**
     * OK
     */
    200: UpdateTracksResponse;
};

export type PutAppsByAppIdSessionsBySessionIdTracksUpdateResponse = PutAppsByAppIdSessionsBySessionIdTracksUpdateResponses[keyof PutAppsByAppIdSessionsBySessionIdTracksUpdateResponses];

export type GetAppsByAppIdSessionsBySessionIdData = {
    body?: never;
    path: {
        /**
         * WebRTC application ID
         */
        appId: string;
        sessionId: string;
    };
    query?: never;
    url: '/apps/{appId}/sessions/{sessionId}';
};

export type GetAppsByAppIdSessionsBySessionIdResponses = {
    /**
     * OK
     */
    200: GetSessionStateResponse;
};

export type GetAppsByAppIdSessionsBySessionIdResponse = GetAppsByAppIdSessionsBySessionIdResponses[keyof GetAppsByAppIdSessionsBySessionIdResponses];

export type ClientOptions = {
    baseUrl: 'https://rtc.live.cloudflare.com/v1' | (string & {});
};